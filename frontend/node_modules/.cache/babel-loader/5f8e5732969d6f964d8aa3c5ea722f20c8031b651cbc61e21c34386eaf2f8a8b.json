{"ast":null,"code":"import { _ as _async_to_generator } from './cc-BU0zEyYq.js';\nimport { useState, useReducer, useRef, useCallback, useEffect } from 'react';\nimport debounce from 'lodash.debounce';\nconst NativeSpeechRecognition = typeof window !== \"undefined\" && (window.SpeechRecognition || window.webkitSpeechRecognition || window.mozSpeechRecognition || window.msSpeechRecognition || window.oSpeechRecognition);\nconst isNative = SpeechRecognition => SpeechRecognition === NativeSpeechRecognition;\nvar isAndroid = () => /(android)/i.test(typeof navigator !== \"undefined\" ? navigator.userAgent : \"\");\nconst concatTranscripts = (...transcriptParts) => {\n  return transcriptParts.map(t => t.trim()).join(\" \").trim();\n};\n// The command matching code is a modified version of Backbone.Router by Jeremy Ashkenas, under the MIT license.\nconst optionalParam = /\\s*\\((.*?)\\)\\s*/g;\nconst optionalRegex = /(\\(\\?:[^)]+\\))\\?/g;\nconst namedParam = /(\\(\\?)?:\\w+/g;\nconst splatParam = /\\*/g;\nconst escapeRegExp = /[-{}[\\]+?.,\\\\^$|#]/g;\nconst commandToRegExp = command => {\n  if (command instanceof RegExp) {\n    return new RegExp(command.source, \"i\");\n  }\n  command = command.replace(escapeRegExp, \"\\\\$&\").replace(optionalParam, \"(?:$1)?\").replace(namedParam, (match, optional) => {\n    return optional ? match : \"([^\\\\s]+)\";\n  }).replace(splatParam, \"(.*?)\").replace(optionalRegex, \"\\\\s*$1?\\\\s*\");\n  return new RegExp(\"^\" + command + \"$\", \"i\");\n};\n// this is from https://github.com/aceakash/string-similarity\nconst compareTwoStringsUsingDiceCoefficient = (first, second) => {\n  first = first.replace(/\\s+/g, \"\").toLowerCase();\n  second = second.replace(/\\s+/g, \"\").toLowerCase();\n  if (!first.length && !second.length) return 1; // if both are empty strings\n  if (!first.length || !second.length) return 0; // if only one is empty string\n  if (first === second) return 1; // identical\n  if (first.length === 1 && second.length === 1) return 0; // both are 1-letter strings\n  if (first.length < 2 || second.length < 2) return 0; // if either is a 1-letter string\n  const firstBigrams = new Map();\n  for (let i = 0; i < first.length - 1; i++) {\n    const bigram = first.substring(i, i + 2);\n    const count = firstBigrams.has(bigram) ? firstBigrams.get(bigram) + 1 : 1;\n    firstBigrams.set(bigram, count);\n  }\n  let intersectionSize = 0;\n  for (let i = 0; i < second.length - 1; i++) {\n    const bigram = second.substring(i, i + 2);\n    const count = firstBigrams.has(bigram) ? firstBigrams.get(bigram) : 0;\n    if (count > 0) {\n      firstBigrams.set(bigram, count - 1);\n      intersectionSize++;\n    }\n  }\n  return 2.0 * intersectionSize / (first.length + second.length - 2);\n};\nconst browserSupportsPolyfills = () => {\n  return typeof window !== \"undefined\" && window.navigator !== undefined && window.navigator.mediaDevices !== undefined && window.navigator.mediaDevices.getUserMedia !== undefined && (window.AudioContext !== undefined || window.webkitAudioContext !== undefined);\n};\nclass RecognitionManager {\n  setSpeechRecognition(SpeechRecognition) {\n    const browserSupportsRecogniser = !!SpeechRecognition && (isNative(SpeechRecognition) || browserSupportsPolyfills());\n    if (browserSupportsRecogniser) {\n      this.disableRecognition();\n      this.recognition = new SpeechRecognition();\n      this.recognition.continuous = false;\n      this.recognition.interimResults = true;\n      this.recognition.onresult = this.updateTranscript.bind(this);\n      this.recognition.onend = this.onRecognitionDisconnect.bind(this);\n      this.recognition.onerror = this.onError.bind(this);\n    }\n    this.emitBrowserSupportsSpeechRecognitionChange(browserSupportsRecogniser);\n  }\n  subscribe(id, callbacks) {\n    this.subscribers[id] = callbacks;\n  }\n  unsubscribe(id) {\n    delete this.subscribers[id];\n  }\n  emitListeningChange(listening) {\n    this.listening = listening;\n    Object.keys(this.subscribers).forEach(id => {\n      const {\n        onListeningChange\n      } = this.subscribers[id];\n      onListeningChange(listening);\n    });\n  }\n  emitMicrophoneAvailabilityChange(isMicrophoneAvailable) {\n    this.isMicrophoneAvailable = isMicrophoneAvailable;\n    Object.keys(this.subscribers).forEach(id => {\n      const {\n        onMicrophoneAvailabilityChange\n      } = this.subscribers[id];\n      onMicrophoneAvailabilityChange(isMicrophoneAvailable);\n    });\n  }\n  emitTranscriptChange(interimTranscript, finalTranscript) {\n    Object.keys(this.subscribers).forEach(id => {\n      const {\n        onTranscriptChange\n      } = this.subscribers[id];\n      onTranscriptChange(interimTranscript, finalTranscript);\n    });\n  }\n  emitClearTranscript() {\n    Object.keys(this.subscribers).forEach(id => {\n      const {\n        onClearTranscript\n      } = this.subscribers[id];\n      onClearTranscript();\n    });\n  }\n  emitBrowserSupportsSpeechRecognitionChange(browserSupportsSpeechRecognitionChange) {\n    Object.keys(this.subscribers).forEach(id => {\n      const {\n        onBrowserSupportsSpeechRecognitionChange,\n        onBrowserSupportsContinuousListeningChange\n      } = this.subscribers[id];\n      onBrowserSupportsSpeechRecognitionChange(browserSupportsSpeechRecognitionChange);\n      onBrowserSupportsContinuousListeningChange(browserSupportsSpeechRecognitionChange);\n    });\n  }\n  disconnect(disconnectType) {\n    if (this.recognition && this.listening) {\n      switch (disconnectType) {\n        case \"ABORT\":\n          this.pauseAfterDisconnect = true;\n          this.abort();\n          break;\n        case \"RESET\":\n          this.pauseAfterDisconnect = false;\n          this.abort();\n          break;\n        case \"STOP\":\n        default:\n          this.pauseAfterDisconnect = true;\n          this.stop();\n      }\n    }\n  }\n  disableRecognition() {\n    if (this.recognition) {\n      this.recognition.onresult = () => {};\n      this.recognition.onend = () => {};\n      this.recognition.onerror = () => {};\n      if (this.listening) {\n        this.stopListening();\n      }\n    }\n  }\n  onError(event) {\n    if (event && event.error && event.error === \"not-allowed\") {\n      this.emitMicrophoneAvailabilityChange(false);\n      this.disableRecognition();\n    }\n  }\n  onRecognitionDisconnect() {\n    this.onStopListening();\n    this.listening = false;\n    if (this.pauseAfterDisconnect) {\n      this.emitListeningChange(false);\n    } else if (this.recognition) {\n      if (this.recognition.continuous) {\n        this.startListening({\n          continuous: this.recognition.continuous\n        });\n      } else {\n        this.emitListeningChange(false);\n      }\n    }\n    this.pauseAfterDisconnect = false;\n  }\n  updateTranscript({\n    results,\n    resultIndex\n  }) {\n    const currentIndex = resultIndex === undefined ? results.length - 1 : resultIndex;\n    this.interimTranscript = \"\";\n    this.finalTranscript = \"\";\n    for (let i = currentIndex; i < results.length; ++i) {\n      if (results[i].isFinal && (!isAndroid() || results[i][0].confidence > 0)) {\n        this.updateFinalTranscript(results[i][0].transcript);\n      } else {\n        this.interimTranscript = concatTranscripts(this.interimTranscript, results[i][0].transcript);\n      }\n    }\n    let isDuplicateResult = false;\n    if (this.interimTranscript === \"\" && this.finalTranscript !== \"\") {\n      if (this.previousResultWasFinalOnly) {\n        isDuplicateResult = true;\n      }\n      this.previousResultWasFinalOnly = true;\n    } else {\n      this.previousResultWasFinalOnly = false;\n    }\n    if (!isDuplicateResult) {\n      this.emitTranscriptChange(this.interimTranscript, this.finalTranscript);\n    }\n  }\n  updateFinalTranscript(newFinalTranscript) {\n    this.finalTranscript = concatTranscripts(this.finalTranscript, newFinalTranscript);\n  }\n  resetTranscript() {\n    this.disconnect(\"RESET\");\n  }\n  startListening() {\n    return /*#__PURE__*/_async_to_generator(function* ({\n      continuous = false,\n      language\n    } = {}) {\n      if (!this.recognition) {\n        return;\n      }\n      const isContinuousChanged = continuous !== this.recognition.continuous;\n      const isLanguageChanged = language && language !== this.recognition.lang;\n      if (isContinuousChanged || isLanguageChanged) {\n        if (this.listening) {\n          yield this.stopListening();\n        }\n        this.recognition.continuous = isContinuousChanged ? continuous : this.recognition.continuous;\n        this.recognition.lang = isLanguageChanged ? language : this.recognition.lang;\n      }\n      if (!this.listening) {\n        if (!this.recognition.continuous) {\n          this.resetTranscript();\n          this.emitClearTranscript();\n        }\n        try {\n          yield this.start();\n          this.emitListeningChange(true);\n        } catch (e) {\n          // DOMExceptions indicate a redundant microphone start - safe to swallow\n          if (!(e instanceof DOMException)) {\n            this.emitMicrophoneAvailabilityChange(false);\n          }\n        }\n      }\n    }).apply(this, arguments);\n  }\n  abortListening() {\n    return /*#__PURE__*/_async_to_generator(function* () {\n      this.disconnect(\"ABORT\");\n      this.emitListeningChange(false);\n      yield new Promise(resolve => {\n        this.onStopListening = resolve;\n      });\n    }).call(this);\n  }\n  stopListening() {\n    return /*#__PURE__*/_async_to_generator(function* () {\n      this.disconnect(\"STOP\");\n      this.emitListeningChange(false);\n      yield new Promise(resolve => {\n        this.onStopListening = resolve;\n      });\n    }).call(this);\n  }\n  getRecognition() {\n    return this.recognition;\n  }\n  start() {\n    return /*#__PURE__*/_async_to_generator(function* () {\n      if (this.recognition && !this.listening) {\n        yield this.recognition.start();\n        this.listening = true;\n      }\n    }).call(this);\n  }\n  stop() {\n    if (this.recognition && this.listening) {\n      this.recognition.stop();\n      this.listening = false;\n    }\n  }\n  abort() {\n    if (this.recognition && this.listening) {\n      this.recognition.abort();\n      this.listening = false;\n    }\n  }\n  constructor(SpeechRecognition) {\n    this.recognition = null;\n    this.pauseAfterDisconnect = false;\n    this.interimTranscript = \"\";\n    this.finalTranscript = \"\";\n    this.listening = false;\n    this.isMicrophoneAvailable = true;\n    this.subscribers = {};\n    this.onStopListening = () => {};\n    this.previousResultWasFinalOnly = false;\n    this.resetTranscript = this.resetTranscript.bind(this);\n    this.startListening = this.startListening.bind(this);\n    this.stopListening = this.stopListening.bind(this);\n    this.abortListening = this.abortListening.bind(this);\n    this.setSpeechRecognition = this.setSpeechRecognition.bind(this);\n    this.disableRecognition = this.disableRecognition.bind(this);\n    this.setSpeechRecognition(SpeechRecognition);\n    if (isAndroid()) {\n      this.updateFinalTranscript = debounce(this.updateFinalTranscript, 250, {\n        leading: true\n      });\n    }\n  }\n}\nconst CLEAR_TRANSCRIPT = \"CLEAR_TRANSCRIPT\";\nconst APPEND_TRANSCRIPT = \"APPEND_TRANSCRIPT\";\nconst clearTranscript = () => {\n  return {\n    type: CLEAR_TRANSCRIPT\n  };\n};\nconst appendTranscript = (interimTranscript, finalTranscript) => {\n  return {\n    type: APPEND_TRANSCRIPT,\n    payload: {\n      interimTranscript,\n      finalTranscript\n    }\n  };\n};\nconst transcriptReducer = (state, action) => {\n  switch (action.type) {\n    case CLEAR_TRANSCRIPT:\n      return {\n        interimTranscript: \"\",\n        finalTranscript: \"\"\n      };\n    case APPEND_TRANSCRIPT:\n      return {\n        interimTranscript: action.payload.interimTranscript,\n        finalTranscript: concatTranscripts(state.finalTranscript, action.payload.finalTranscript)\n      };\n    default:\n      throw new Error();\n  }\n};\nlet _browserSupportsSpeechRecognition = !!NativeSpeechRecognition;\nlet _browserSupportsContinuousListening = _browserSupportsSpeechRecognition && !isAndroid();\nlet recognitionManager;\nconst useSpeechRecognition = ({\n  transcribing = true,\n  clearTranscriptOnListen = true,\n  commands = []\n} = {}) => {\n  const [recognitionManager] = useState(SpeechRecognition.getRecognitionManager());\n  const [browserSupportsSpeechRecognition, setBrowserSupportsSpeechRecognition] = useState(_browserSupportsSpeechRecognition);\n  const [browserSupportsContinuousListening, setBrowserSupportsContinuousListening] = useState(_browserSupportsContinuousListening);\n  const [{\n    interimTranscript,\n    finalTranscript\n  }, dispatch] = useReducer(transcriptReducer, {\n    interimTranscript: recognitionManager.interimTranscript,\n    finalTranscript: \"\"\n  });\n  const [listening, setListening] = useState(recognitionManager.listening);\n  const [isMicrophoneAvailable, setMicrophoneAvailable] = useState(recognitionManager.isMicrophoneAvailable);\n  const commandsRef = useRef(commands);\n  commandsRef.current = commands;\n  const dispatchClearTranscript = () => {\n    dispatch(clearTranscript());\n  };\n  const resetTranscript = useCallback(() => {\n    recognitionManager.resetTranscript();\n    dispatchClearTranscript();\n  }, [recognitionManager]);\n  const testFuzzyMatch = (command, input, fuzzyMatchingThreshold) => {\n    const commandToString = typeof command === \"object\" ? command.toString() : command;\n    const commandWithoutSpecials = commandToString.replace(/[&/\\\\#,+()!$~%.'\":*?<>{}]/g, \"\").replace(/  +/g, \" \").trim();\n    const howSimilar = compareTwoStringsUsingDiceCoefficient(commandWithoutSpecials, input);\n    if (howSimilar >= fuzzyMatchingThreshold) {\n      return {\n        command,\n        commandWithoutSpecials,\n        howSimilar,\n        isFuzzyMatch: true\n      };\n    }\n    return null;\n  };\n  const testMatch = (command, input) => {\n    const pattern = commandToRegExp(command);\n    const result = pattern.exec(input);\n    if (result) {\n      return {\n        command,\n        parameters: result.slice(1)\n      };\n    }\n    return null;\n  };\n  const matchCommands = useCallback((newInterimTranscript, newFinalTranscript) => {\n    commandsRef.current.forEach(({\n      command,\n      callback,\n      matchInterim = false,\n      isFuzzyMatch = false,\n      fuzzyMatchingThreshold = 0.8,\n      bestMatchOnly = false\n    }) => {\n      const input = !newFinalTranscript && matchInterim ? newInterimTranscript.trim() : newFinalTranscript.trim();\n      const subcommands = Array.isArray(command) ? command : [command];\n      const results = subcommands.map(subcommand => {\n        if (isFuzzyMatch) {\n          return testFuzzyMatch(subcommand, input, fuzzyMatchingThreshold);\n        }\n        return testMatch(subcommand, input);\n      }).filter(x => x);\n      if (isFuzzyMatch && bestMatchOnly && results.length >= 2) {\n        results.sort((a, b) => b.howSimilar - a.howSimilar);\n        const {\n          command,\n          commandWithoutSpecials,\n          howSimilar\n        } = results[0];\n        callback(commandWithoutSpecials, input, howSimilar, {\n          command,\n          resetTranscript\n        });\n      } else {\n        results.forEach(result => {\n          if (result.isFuzzyMatch) {\n            const {\n              command,\n              commandWithoutSpecials,\n              howSimilar\n            } = result;\n            callback(commandWithoutSpecials, input, howSimilar, {\n              command,\n              resetTranscript\n            });\n          } else {\n            const {\n              command,\n              parameters\n            } = result;\n            callback(...parameters, {\n              command,\n              resetTranscript\n            });\n          }\n        });\n      }\n    });\n  }, [resetTranscript]);\n  const handleTranscriptChange = useCallback((newInterimTranscript, newFinalTranscript) => {\n    if (transcribing) {\n      dispatch(appendTranscript(newInterimTranscript, newFinalTranscript));\n    }\n    matchCommands(newInterimTranscript, newFinalTranscript);\n  }, [matchCommands, transcribing]);\n  const handleClearTranscript = useCallback(() => {\n    if (clearTranscriptOnListen) {\n      dispatchClearTranscript();\n    }\n  }, [clearTranscriptOnListen]);\n  useEffect(() => {\n    const id = SpeechRecognition.counter;\n    SpeechRecognition.counter += 1;\n    const callbacks = {\n      onListeningChange: setListening,\n      onMicrophoneAvailabilityChange: setMicrophoneAvailable,\n      onTranscriptChange: handleTranscriptChange,\n      onClearTranscript: handleClearTranscript,\n      onBrowserSupportsSpeechRecognitionChange: setBrowserSupportsSpeechRecognition,\n      onBrowserSupportsContinuousListeningChange: setBrowserSupportsContinuousListening\n    };\n    recognitionManager.subscribe(id, callbacks);\n    return () => {\n      recognitionManager.unsubscribe(id);\n    };\n  }, [transcribing, clearTranscriptOnListen, recognitionManager, handleTranscriptChange, handleClearTranscript]);\n  const transcript = concatTranscripts(finalTranscript, interimTranscript);\n  return {\n    transcript,\n    interimTranscript,\n    finalTranscript,\n    listening,\n    isMicrophoneAvailable,\n    resetTranscript,\n    browserSupportsSpeechRecognition,\n    browserSupportsContinuousListening\n  };\n};\nconst SpeechRecognition = {\n  counter: 0,\n  applyPolyfill: PolyfillSpeechRecognition => {\n    if (recognitionManager) {\n      recognitionManager.setSpeechRecognition(PolyfillSpeechRecognition);\n    } else {\n      recognitionManager = new RecognitionManager(PolyfillSpeechRecognition);\n    }\n    const browserSupportsPolyfill = !!PolyfillSpeechRecognition && browserSupportsPolyfills();\n    _browserSupportsSpeechRecognition = browserSupportsPolyfill;\n    _browserSupportsContinuousListening = browserSupportsPolyfill;\n  },\n  removePolyfill: () => {\n    if (recognitionManager) {\n      recognitionManager.setSpeechRecognition(NativeSpeechRecognition);\n    } else {\n      recognitionManager = new RecognitionManager(NativeSpeechRecognition);\n    }\n    _browserSupportsSpeechRecognition = !!NativeSpeechRecognition;\n    _browserSupportsContinuousListening = _browserSupportsSpeechRecognition && !isAndroid();\n  },\n  getRecognitionManager: () => {\n    if (!recognitionManager) {\n      recognitionManager = new RecognitionManager(NativeSpeechRecognition);\n    }\n    return recognitionManager;\n  },\n  getRecognition: () => {\n    const recognitionManager = SpeechRecognition.getRecognitionManager();\n    return recognitionManager.getRecognition();\n  },\n  startListening: ({\n    continuous,\n    language\n  } = {}) => /*#__PURE__*/_async_to_generator(function* () {\n    const recognitionManager = SpeechRecognition.getRecognitionManager();\n    yield recognitionManager.startListening({\n      continuous,\n      language\n    });\n  })(),\n  stopListening: () => /*#__PURE__*/_async_to_generator(function* () {\n    const recognitionManager = SpeechRecognition.getRecognitionManager();\n    yield recognitionManager.stopListening();\n  })(),\n  abortListening: () => /*#__PURE__*/_async_to_generator(function* () {\n    const recognitionManager = SpeechRecognition.getRecognitionManager();\n    yield recognitionManager.abortListening();\n  })(),\n  browserSupportsSpeechRecognition: () => _browserSupportsSpeechRecognition,\n  browserSupportsContinuousListening: () => _browserSupportsContinuousListening\n};\nexport { SpeechRecognition as default, useSpeechRecognition };","map":{"version":3,"names":["_","_async_to_generator","useState","useReducer","useRef","useCallback","useEffect","debounce","NativeSpeechRecognition","window","SpeechRecognition","webkitSpeechRecognition","mozSpeechRecognition","msSpeechRecognition","oSpeechRecognition","isNative","isAndroid","test","navigator","userAgent","concatTranscripts","transcriptParts","map","t","trim","join","optionalParam","optionalRegex","namedParam","splatParam","escapeRegExp","commandToRegExp","command","RegExp","source","replace","match","optional","compareTwoStringsUsingDiceCoefficient","first","second","toLowerCase","length","firstBigrams","Map","i","bigram","substring","count","has","get","set","intersectionSize","browserSupportsPolyfills","undefined","mediaDevices","getUserMedia","AudioContext","webkitAudioContext","RecognitionManager","setSpeechRecognition","browserSupportsRecogniser","disableRecognition","recognition","continuous","interimResults","onresult","updateTranscript","bind","onend","onRecognitionDisconnect","onerror","onError","emitBrowserSupportsSpeechRecognitionChange","subscribe","id","callbacks","subscribers","unsubscribe","emitListeningChange","listening","Object","keys","forEach","onListeningChange","emitMicrophoneAvailabilityChange","isMicrophoneAvailable","onMicrophoneAvailabilityChange","emitTranscriptChange","interimTranscript","finalTranscript","onTranscriptChange","emitClearTranscript","onClearTranscript","browserSupportsSpeechRecognitionChange","onBrowserSupportsSpeechRecognitionChange","onBrowserSupportsContinuousListeningChange","disconnect","disconnectType","pauseAfterDisconnect","abort","stop","stopListening","event","error","onStopListening","startListening","results","resultIndex","currentIndex","isFinal","confidence","updateFinalTranscript","transcript","isDuplicateResult","previousResultWasFinalOnly","newFinalTranscript","resetTranscript","language","isContinuousChanged","isLanguageChanged","lang","start","e","DOMException","apply","arguments","abortListening","Promise","resolve","call","getRecognition","constructor","leading","CLEAR_TRANSCRIPT","APPEND_TRANSCRIPT","clearTranscript","type","appendTranscript","payload","transcriptReducer","state","action","Error","_browserSupportsSpeechRecognition","_browserSupportsContinuousListening","recognitionManager","useSpeechRecognition","transcribing","clearTranscriptOnListen","commands","getRecognitionManager","browserSupportsSpeechRecognition","setBrowserSupportsSpeechRecognition","browserSupportsContinuousListening","setBrowserSupportsContinuousListening","dispatch","setListening","setMicrophoneAvailable","commandsRef","current","dispatchClearTranscript","testFuzzyMatch","input","fuzzyMatchingThreshold","commandToString","toString","commandWithoutSpecials","howSimilar","isFuzzyMatch","testMatch","pattern","result","exec","parameters","slice","matchCommands","newInterimTranscript","callback","matchInterim","bestMatchOnly","subcommands","Array","isArray","subcommand","filter","x","sort","a","b","handleTranscriptChange","handleClearTranscript","counter","applyPolyfill","PolyfillSpeechRecognition","browserSupportsPolyfill","removePolyfill","default"],"sources":["/Users/apple/node_modules/react-speech-recognition/dist/index.js"],"sourcesContent":["import { _ as _async_to_generator } from './cc-BU0zEyYq.js';\nimport { useState, useReducer, useRef, useCallback, useEffect } from 'react';\nimport debounce from 'lodash.debounce';\n\nconst NativeSpeechRecognition = typeof window !== \"undefined\" && (window.SpeechRecognition || window.webkitSpeechRecognition || window.mozSpeechRecognition || window.msSpeechRecognition || window.oSpeechRecognition);\nconst isNative = (SpeechRecognition)=>SpeechRecognition === NativeSpeechRecognition;\n\nvar isAndroid = (()=>/(android)/i.test(typeof navigator !== \"undefined\" ? navigator.userAgent : \"\"));\n\nconst concatTranscripts = (...transcriptParts)=>{\n    return transcriptParts.map((t)=>t.trim()).join(\" \").trim();\n};\n// The command matching code is a modified version of Backbone.Router by Jeremy Ashkenas, under the MIT license.\nconst optionalParam = /\\s*\\((.*?)\\)\\s*/g;\nconst optionalRegex = /(\\(\\?:[^)]+\\))\\?/g;\nconst namedParam = /(\\(\\?)?:\\w+/g;\nconst splatParam = /\\*/g;\nconst escapeRegExp = /[-{}[\\]+?.,\\\\^$|#]/g;\nconst commandToRegExp = (command)=>{\n    if (command instanceof RegExp) {\n        return new RegExp(command.source, \"i\");\n    }\n    command = command.replace(escapeRegExp, \"\\\\$&\").replace(optionalParam, \"(?:$1)?\").replace(namedParam, (match, optional)=>{\n        return optional ? match : \"([^\\\\s]+)\";\n    }).replace(splatParam, \"(.*?)\").replace(optionalRegex, \"\\\\s*$1?\\\\s*\");\n    return new RegExp(\"^\" + command + \"$\", \"i\");\n};\n// this is from https://github.com/aceakash/string-similarity\nconst compareTwoStringsUsingDiceCoefficient = (first, second)=>{\n    first = first.replace(/\\s+/g, \"\").toLowerCase();\n    second = second.replace(/\\s+/g, \"\").toLowerCase();\n    if (!first.length && !second.length) return 1; // if both are empty strings\n    if (!first.length || !second.length) return 0; // if only one is empty string\n    if (first === second) return 1; // identical\n    if (first.length === 1 && second.length === 1) return 0; // both are 1-letter strings\n    if (first.length < 2 || second.length < 2) return 0; // if either is a 1-letter string\n    const firstBigrams = new Map();\n    for(let i = 0; i < first.length - 1; i++){\n        const bigram = first.substring(i, i + 2);\n        const count = firstBigrams.has(bigram) ? firstBigrams.get(bigram) + 1 : 1;\n        firstBigrams.set(bigram, count);\n    }\n    let intersectionSize = 0;\n    for(let i = 0; i < second.length - 1; i++){\n        const bigram = second.substring(i, i + 2);\n        const count = firstBigrams.has(bigram) ? firstBigrams.get(bigram) : 0;\n        if (count > 0) {\n            firstBigrams.set(bigram, count - 1);\n            intersectionSize++;\n        }\n    }\n    return 2.0 * intersectionSize / (first.length + second.length - 2);\n};\nconst browserSupportsPolyfills = ()=>{\n    return typeof window !== \"undefined\" && window.navigator !== undefined && window.navigator.mediaDevices !== undefined && window.navigator.mediaDevices.getUserMedia !== undefined && (window.AudioContext !== undefined || window.webkitAudioContext !== undefined);\n};\n\nclass RecognitionManager {\n    setSpeechRecognition(SpeechRecognition) {\n        const browserSupportsRecogniser = !!SpeechRecognition && (isNative(SpeechRecognition) || browserSupportsPolyfills());\n        if (browserSupportsRecogniser) {\n            this.disableRecognition();\n            this.recognition = new SpeechRecognition();\n            this.recognition.continuous = false;\n            this.recognition.interimResults = true;\n            this.recognition.onresult = this.updateTranscript.bind(this);\n            this.recognition.onend = this.onRecognitionDisconnect.bind(this);\n            this.recognition.onerror = this.onError.bind(this);\n        }\n        this.emitBrowserSupportsSpeechRecognitionChange(browserSupportsRecogniser);\n    }\n    subscribe(id, callbacks) {\n        this.subscribers[id] = callbacks;\n    }\n    unsubscribe(id) {\n        delete this.subscribers[id];\n    }\n    emitListeningChange(listening) {\n        this.listening = listening;\n        Object.keys(this.subscribers).forEach((id)=>{\n            const { onListeningChange } = this.subscribers[id];\n            onListeningChange(listening);\n        });\n    }\n    emitMicrophoneAvailabilityChange(isMicrophoneAvailable) {\n        this.isMicrophoneAvailable = isMicrophoneAvailable;\n        Object.keys(this.subscribers).forEach((id)=>{\n            const { onMicrophoneAvailabilityChange } = this.subscribers[id];\n            onMicrophoneAvailabilityChange(isMicrophoneAvailable);\n        });\n    }\n    emitTranscriptChange(interimTranscript, finalTranscript) {\n        Object.keys(this.subscribers).forEach((id)=>{\n            const { onTranscriptChange } = this.subscribers[id];\n            onTranscriptChange(interimTranscript, finalTranscript);\n        });\n    }\n    emitClearTranscript() {\n        Object.keys(this.subscribers).forEach((id)=>{\n            const { onClearTranscript } = this.subscribers[id];\n            onClearTranscript();\n        });\n    }\n    emitBrowserSupportsSpeechRecognitionChange(browserSupportsSpeechRecognitionChange) {\n        Object.keys(this.subscribers).forEach((id)=>{\n            const { onBrowserSupportsSpeechRecognitionChange, onBrowserSupportsContinuousListeningChange } = this.subscribers[id];\n            onBrowserSupportsSpeechRecognitionChange(browserSupportsSpeechRecognitionChange);\n            onBrowserSupportsContinuousListeningChange(browserSupportsSpeechRecognitionChange);\n        });\n    }\n    disconnect(disconnectType) {\n        if (this.recognition && this.listening) {\n            switch(disconnectType){\n                case \"ABORT\":\n                    this.pauseAfterDisconnect = true;\n                    this.abort();\n                    break;\n                case \"RESET\":\n                    this.pauseAfterDisconnect = false;\n                    this.abort();\n                    break;\n                case \"STOP\":\n                default:\n                    this.pauseAfterDisconnect = true;\n                    this.stop();\n            }\n        }\n    }\n    disableRecognition() {\n        if (this.recognition) {\n            this.recognition.onresult = ()=>{};\n            this.recognition.onend = ()=>{};\n            this.recognition.onerror = ()=>{};\n            if (this.listening) {\n                this.stopListening();\n            }\n        }\n    }\n    onError(event) {\n        if (event && event.error && event.error === \"not-allowed\") {\n            this.emitMicrophoneAvailabilityChange(false);\n            this.disableRecognition();\n        }\n    }\n    onRecognitionDisconnect() {\n        this.onStopListening();\n        this.listening = false;\n        if (this.pauseAfterDisconnect) {\n            this.emitListeningChange(false);\n        } else if (this.recognition) {\n            if (this.recognition.continuous) {\n                this.startListening({\n                    continuous: this.recognition.continuous\n                });\n            } else {\n                this.emitListeningChange(false);\n            }\n        }\n        this.pauseAfterDisconnect = false;\n    }\n    updateTranscript({ results, resultIndex }) {\n        const currentIndex = resultIndex === undefined ? results.length - 1 : resultIndex;\n        this.interimTranscript = \"\";\n        this.finalTranscript = \"\";\n        for(let i = currentIndex; i < results.length; ++i){\n            if (results[i].isFinal && (!isAndroid() || results[i][0].confidence > 0)) {\n                this.updateFinalTranscript(results[i][0].transcript);\n            } else {\n                this.interimTranscript = concatTranscripts(this.interimTranscript, results[i][0].transcript);\n            }\n        }\n        let isDuplicateResult = false;\n        if (this.interimTranscript === \"\" && this.finalTranscript !== \"\") {\n            if (this.previousResultWasFinalOnly) {\n                isDuplicateResult = true;\n            }\n            this.previousResultWasFinalOnly = true;\n        } else {\n            this.previousResultWasFinalOnly = false;\n        }\n        if (!isDuplicateResult) {\n            this.emitTranscriptChange(this.interimTranscript, this.finalTranscript);\n        }\n    }\n    updateFinalTranscript(newFinalTranscript) {\n        this.finalTranscript = concatTranscripts(this.finalTranscript, newFinalTranscript);\n    }\n    resetTranscript() {\n        this.disconnect(\"RESET\");\n    }\n    startListening() {\n        return /*#__PURE__*/ _async_to_generator(function*({ continuous = false, language } = {}) {\n            if (!this.recognition) {\n                return;\n            }\n            const isContinuousChanged = continuous !== this.recognition.continuous;\n            const isLanguageChanged = language && language !== this.recognition.lang;\n            if (isContinuousChanged || isLanguageChanged) {\n                if (this.listening) {\n                    yield this.stopListening();\n                }\n                this.recognition.continuous = isContinuousChanged ? continuous : this.recognition.continuous;\n                this.recognition.lang = isLanguageChanged ? language : this.recognition.lang;\n            }\n            if (!this.listening) {\n                if (!this.recognition.continuous) {\n                    this.resetTranscript();\n                    this.emitClearTranscript();\n                }\n                try {\n                    yield this.start();\n                    this.emitListeningChange(true);\n                } catch (e) {\n                    // DOMExceptions indicate a redundant microphone start - safe to swallow\n                    if (!(e instanceof DOMException)) {\n                        this.emitMicrophoneAvailabilityChange(false);\n                    }\n                }\n            }\n        }).apply(this, arguments);\n    }\n    abortListening() {\n        return /*#__PURE__*/ _async_to_generator(function*() {\n            this.disconnect(\"ABORT\");\n            this.emitListeningChange(false);\n            yield new Promise((resolve)=>{\n                this.onStopListening = resolve;\n            });\n        }).call(this);\n    }\n    stopListening() {\n        return /*#__PURE__*/ _async_to_generator(function*() {\n            this.disconnect(\"STOP\");\n            this.emitListeningChange(false);\n            yield new Promise((resolve)=>{\n                this.onStopListening = resolve;\n            });\n        }).call(this);\n    }\n    getRecognition() {\n        return this.recognition;\n    }\n    start() {\n        return /*#__PURE__*/ _async_to_generator(function*() {\n            if (this.recognition && !this.listening) {\n                yield this.recognition.start();\n                this.listening = true;\n            }\n        }).call(this);\n    }\n    stop() {\n        if (this.recognition && this.listening) {\n            this.recognition.stop();\n            this.listening = false;\n        }\n    }\n    abort() {\n        if (this.recognition && this.listening) {\n            this.recognition.abort();\n            this.listening = false;\n        }\n    }\n    constructor(SpeechRecognition){\n        this.recognition = null;\n        this.pauseAfterDisconnect = false;\n        this.interimTranscript = \"\";\n        this.finalTranscript = \"\";\n        this.listening = false;\n        this.isMicrophoneAvailable = true;\n        this.subscribers = {};\n        this.onStopListening = ()=>{};\n        this.previousResultWasFinalOnly = false;\n        this.resetTranscript = this.resetTranscript.bind(this);\n        this.startListening = this.startListening.bind(this);\n        this.stopListening = this.stopListening.bind(this);\n        this.abortListening = this.abortListening.bind(this);\n        this.setSpeechRecognition = this.setSpeechRecognition.bind(this);\n        this.disableRecognition = this.disableRecognition.bind(this);\n        this.setSpeechRecognition(SpeechRecognition);\n        if (isAndroid()) {\n            this.updateFinalTranscript = debounce(this.updateFinalTranscript, 250, {\n                leading: true\n            });\n        }\n    }\n}\n\nconst CLEAR_TRANSCRIPT = \"CLEAR_TRANSCRIPT\";\nconst APPEND_TRANSCRIPT = \"APPEND_TRANSCRIPT\";\n\nconst clearTranscript = ()=>{\n    return {\n        type: CLEAR_TRANSCRIPT\n    };\n};\nconst appendTranscript = (interimTranscript, finalTranscript)=>{\n    return {\n        type: APPEND_TRANSCRIPT,\n        payload: {\n            interimTranscript,\n            finalTranscript\n        }\n    };\n};\n\nconst transcriptReducer = (state, action)=>{\n    switch(action.type){\n        case CLEAR_TRANSCRIPT:\n            return {\n                interimTranscript: \"\",\n                finalTranscript: \"\"\n            };\n        case APPEND_TRANSCRIPT:\n            return {\n                interimTranscript: action.payload.interimTranscript,\n                finalTranscript: concatTranscripts(state.finalTranscript, action.payload.finalTranscript)\n            };\n        default:\n            throw new Error();\n    }\n};\n\nlet _browserSupportsSpeechRecognition = !!NativeSpeechRecognition;\nlet _browserSupportsContinuousListening = _browserSupportsSpeechRecognition && !isAndroid();\nlet recognitionManager;\nconst useSpeechRecognition = ({ transcribing = true, clearTranscriptOnListen = true, commands = [] } = {})=>{\n    const [recognitionManager] = useState(SpeechRecognition.getRecognitionManager());\n    const [browserSupportsSpeechRecognition, setBrowserSupportsSpeechRecognition] = useState(_browserSupportsSpeechRecognition);\n    const [browserSupportsContinuousListening, setBrowserSupportsContinuousListening] = useState(_browserSupportsContinuousListening);\n    const [{ interimTranscript, finalTranscript }, dispatch] = useReducer(transcriptReducer, {\n        interimTranscript: recognitionManager.interimTranscript,\n        finalTranscript: \"\"\n    });\n    const [listening, setListening] = useState(recognitionManager.listening);\n    const [isMicrophoneAvailable, setMicrophoneAvailable] = useState(recognitionManager.isMicrophoneAvailable);\n    const commandsRef = useRef(commands);\n    commandsRef.current = commands;\n    const dispatchClearTranscript = ()=>{\n        dispatch(clearTranscript());\n    };\n    const resetTranscript = useCallback(()=>{\n        recognitionManager.resetTranscript();\n        dispatchClearTranscript();\n    }, [\n        recognitionManager\n    ]);\n    const testFuzzyMatch = (command, input, fuzzyMatchingThreshold)=>{\n        const commandToString = typeof command === \"object\" ? command.toString() : command;\n        const commandWithoutSpecials = commandToString.replace(/[&/\\\\#,+()!$~%.'\":*?<>{}]/g, \"\").replace(/  +/g, \" \").trim();\n        const howSimilar = compareTwoStringsUsingDiceCoefficient(commandWithoutSpecials, input);\n        if (howSimilar >= fuzzyMatchingThreshold) {\n            return {\n                command,\n                commandWithoutSpecials,\n                howSimilar,\n                isFuzzyMatch: true\n            };\n        }\n        return null;\n    };\n    const testMatch = (command, input)=>{\n        const pattern = commandToRegExp(command);\n        const result = pattern.exec(input);\n        if (result) {\n            return {\n                command,\n                parameters: result.slice(1)\n            };\n        }\n        return null;\n    };\n    const matchCommands = useCallback((newInterimTranscript, newFinalTranscript)=>{\n        commandsRef.current.forEach(({ command, callback, matchInterim = false, isFuzzyMatch = false, fuzzyMatchingThreshold = 0.8, bestMatchOnly = false })=>{\n            const input = !newFinalTranscript && matchInterim ? newInterimTranscript.trim() : newFinalTranscript.trim();\n            const subcommands = Array.isArray(command) ? command : [\n                command\n            ];\n            const results = subcommands.map((subcommand)=>{\n                if (isFuzzyMatch) {\n                    return testFuzzyMatch(subcommand, input, fuzzyMatchingThreshold);\n                }\n                return testMatch(subcommand, input);\n            }).filter((x)=>x);\n            if (isFuzzyMatch && bestMatchOnly && results.length >= 2) {\n                results.sort((a, b)=>b.howSimilar - a.howSimilar);\n                const { command, commandWithoutSpecials, howSimilar } = results[0];\n                callback(commandWithoutSpecials, input, howSimilar, {\n                    command,\n                    resetTranscript\n                });\n            } else {\n                results.forEach((result)=>{\n                    if (result.isFuzzyMatch) {\n                        const { command, commandWithoutSpecials, howSimilar } = result;\n                        callback(commandWithoutSpecials, input, howSimilar, {\n                            command,\n                            resetTranscript\n                        });\n                    } else {\n                        const { command, parameters } = result;\n                        callback(...parameters, {\n                            command,\n                            resetTranscript\n                        });\n                    }\n                });\n            }\n        });\n    }, [\n        resetTranscript\n    ]);\n    const handleTranscriptChange = useCallback((newInterimTranscript, newFinalTranscript)=>{\n        if (transcribing) {\n            dispatch(appendTranscript(newInterimTranscript, newFinalTranscript));\n        }\n        matchCommands(newInterimTranscript, newFinalTranscript);\n    }, [\n        matchCommands,\n        transcribing\n    ]);\n    const handleClearTranscript = useCallback(()=>{\n        if (clearTranscriptOnListen) {\n            dispatchClearTranscript();\n        }\n    }, [\n        clearTranscriptOnListen\n    ]);\n    useEffect(()=>{\n        const id = SpeechRecognition.counter;\n        SpeechRecognition.counter += 1;\n        const callbacks = {\n            onListeningChange: setListening,\n            onMicrophoneAvailabilityChange: setMicrophoneAvailable,\n            onTranscriptChange: handleTranscriptChange,\n            onClearTranscript: handleClearTranscript,\n            onBrowserSupportsSpeechRecognitionChange: setBrowserSupportsSpeechRecognition,\n            onBrowserSupportsContinuousListeningChange: setBrowserSupportsContinuousListening\n        };\n        recognitionManager.subscribe(id, callbacks);\n        return ()=>{\n            recognitionManager.unsubscribe(id);\n        };\n    }, [\n        transcribing,\n        clearTranscriptOnListen,\n        recognitionManager,\n        handleTranscriptChange,\n        handleClearTranscript\n    ]);\n    const transcript = concatTranscripts(finalTranscript, interimTranscript);\n    return {\n        transcript,\n        interimTranscript,\n        finalTranscript,\n        listening,\n        isMicrophoneAvailable,\n        resetTranscript,\n        browserSupportsSpeechRecognition,\n        browserSupportsContinuousListening\n    };\n};\nconst SpeechRecognition = {\n    counter: 0,\n    applyPolyfill: (PolyfillSpeechRecognition)=>{\n        if (recognitionManager) {\n            recognitionManager.setSpeechRecognition(PolyfillSpeechRecognition);\n        } else {\n            recognitionManager = new RecognitionManager(PolyfillSpeechRecognition);\n        }\n        const browserSupportsPolyfill = !!PolyfillSpeechRecognition && browserSupportsPolyfills();\n        _browserSupportsSpeechRecognition = browserSupportsPolyfill;\n        _browserSupportsContinuousListening = browserSupportsPolyfill;\n    },\n    removePolyfill: ()=>{\n        if (recognitionManager) {\n            recognitionManager.setSpeechRecognition(NativeSpeechRecognition);\n        } else {\n            recognitionManager = new RecognitionManager(NativeSpeechRecognition);\n        }\n        _browserSupportsSpeechRecognition = !!NativeSpeechRecognition;\n        _browserSupportsContinuousListening = _browserSupportsSpeechRecognition && !isAndroid();\n    },\n    getRecognitionManager: ()=>{\n        if (!recognitionManager) {\n            recognitionManager = new RecognitionManager(NativeSpeechRecognition);\n        }\n        return recognitionManager;\n    },\n    getRecognition: ()=>{\n        const recognitionManager = SpeechRecognition.getRecognitionManager();\n        return recognitionManager.getRecognition();\n    },\n    startListening: ({ continuous, language } = {})=>/*#__PURE__*/ _async_to_generator(function*() {\n            const recognitionManager = SpeechRecognition.getRecognitionManager();\n            yield recognitionManager.startListening({\n                continuous,\n                language\n            });\n        })(),\n    stopListening: ()=>/*#__PURE__*/ _async_to_generator(function*() {\n            const recognitionManager = SpeechRecognition.getRecognitionManager();\n            yield recognitionManager.stopListening();\n        })(),\n    abortListening: ()=>/*#__PURE__*/ _async_to_generator(function*() {\n            const recognitionManager = SpeechRecognition.getRecognitionManager();\n            yield recognitionManager.abortListening();\n        })(),\n    browserSupportsSpeechRecognition: ()=>_browserSupportsSpeechRecognition,\n    browserSupportsContinuousListening: ()=>_browserSupportsContinuousListening\n};\n\nexport { SpeechRecognition as default, useSpeechRecognition };\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}